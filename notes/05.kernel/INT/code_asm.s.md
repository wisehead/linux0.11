#1.硬件中断处理程序

中断信号通常可以分为两类:硬件中断和软件中断(异常)。每个中断是由 0-255 之间的一个数字来标 识。对于中断 int0--int31(0x00--0x1f)，每个中断的功能是由 Intel 固定设定或保留用的, 属于软件中断， 但 Intel 称之为异常。因为是由 CPU 执行指令时探测到异常时引起的。通常还可分为故障(Fault)和陷阱 (traps)两类。中断 int32--int255 (0x20--0xff)可以由用户自己设定。在 Linux 系统中，则将 int32--int47(0x20--0x2f)对应于 8259A 中断控制芯片发出的硬件中断请求信号 IRQ0-IRQ15;并把程序编 程发出的系统调用(system_call)中断设置为 int128(0x80)。

在将控制权交给中断处理程序之前，CPU 会首先将至少 12 字节的信息压入中断处理程序的堆栈中。 这种情况与一个长调用(段间子程序调用)比较相象。CPU 会将代码段选择符和返回地址的偏移值压入 堆栈。另一个与段间调用比较相象的地方是 80386 将信息压入到了目的代码的堆栈上，而不是被中断代 码的堆栈。另外，CPU 还总是将标志寄存器 EFLAGS 的内容压入堆栈。如果优先级别发生了变化，比如 从用户级改变到内核系统级，CPU 还会将原代码的堆栈段值和堆栈指针压入中断程序的堆栈中。对于具 有优先级改变时堆栈的内容示意图见图 5.1 所示。

![](res/t5.1.png)

asm.s 代码文件主要涉及对 Intel 保留中断 int0--int16 的处理，其余保留的中断 int17-int31 由 Intel 公 司留作今后扩充使用。对应于中断控制器芯片各 IRQ 发出的 int32-int47 的 16 个处理程序将分别在各种 硬件(如时钟、键盘、软盘、数学协处理器、硬盘等)初始化程序中处理。Linux 系统调用中断 int128(0x80) 的处理则将在 kernel/system_call.s 中给出。各个中断的具体定义见代码注释后其它信息一节中的说明。

由于有些异常引起中断时，CPU 内部会产生一个出错代码压入堆栈(异常中断 int 8 和 int10 - int 14)， 见图 5.1 所示，而其它的中断却并不带有这个出错代码(例如被零除出错和边界检查出错等)，因此，asm.s 程序中将所有中断的处理根据是否携带出错代码而分别进行处理。但处理流程还是一样的。

#2.硬件异常所引起的中断的处理过程

对一个硬件异常所引起的中断的处理过程见下度所示(图 5.2)。

![](res/t5.2.png)

#3.asm.s

asm.s 汇编程序中包括大部分 CPU 探测到的异常故障处理的底层代码，也包括数学协处理器(FPU) 的异常处理。该程序与 kernel/traps.c 程序有着密切的关系。该程序的主要处理方式是在中断处理程序中 调用相应的 C 函数程序，显示出错位置和出错号，然后退出中断。

在阅读这段代码时参照下面堆栈变化示意图将是很有帮助的(图中每个行代表 4 个字节)。在开始执 行程序之前，堆栈指针 esp 指在中断返回地址一栏(图中 esp0 处)。当把将要调用的 C 函数 do_divide_error() 或其它 C 函数地址入栈后，指针位置是 esp1 处,此时通过交换指令，该函数的地址被放入 eax 寄存器中， 而原来 eax 的值被保存到堆栈上。在把一些寄存器入栈后，堆栈指针位置在 esp2 处。当正式调用 do_divide_error()之前，程序将开始执行时的 esp0 堆栈指针值压入堆栈，放到了 esp3 处，并在中断返回 弹出入栈的寄存器之前指针通过加上 8 又回到 esp2 处。

![](res/t5.3.png)

正式调用 do_divide_error()之前把出错代码以及 esp0 入栈的原因是为了作为调用 C 函数do_divide_error()的参数。在 traps.c 中该函数的原形为:
void do_divide_error(long esp, long error_code)。

因此在这个 C 函数中就可以打印出出错的位置和错误号。程序中其余异常出错的处理过程与这里描 述的过程基本类似。

#4.系统调用处理过程的整个流程

系统调用处理过程的整个流程见图 5.4 所示。

![](res/t5.4.png)