#1.rs_write

```cpp
/*
* 在tty_write()已将数据放入输出(写)队列时会调用下面的子程序。必须首先
* 检查写队列是否为空，并相应设置中断寄存器。
*/
//// 串行数据发送输出。
// 实际上只是开启串行发送保持寄存器已空中断标志，在UART 将数据发送出去后允许发中断信号。
void rs_write (struct tty_struct *tty)
{
    cli ();         // 关中断。
// 如果写队列不空，则从0x3f9(或0x2f9) 首先读取中断允许寄存器内容，添上发送保持寄存器
// 中断允许标志（位1）后，再写回该寄存器。
    if (!EMPTY (tty->write_q))
        outb (inb_p (tty->write_q.data + 1) | 0x02, tty->write_q.data + 1);
    sti ();         // 开中断。
}
```

#2.caller

```cpp
// tty 数据结构的tty_table 数组。其中包含三个初始化项数据，分别对应控制台、串口终端1 和
// 串口终端2 的初始化数据。
struct tty_struct tty_table[] = {
{
    {
        0,          /* no translation */// 输入模式标志。0，无须转换。
        0,          /* no translation */// 输出模式标志。0，无须转换。
        B2400 | CS8,        // 控制模式标志。波特率2400bps，8 位数据位。
        0,          // 本地模式标志0。
        0,          // 行规程0。
        INIT_C_CC
    },      // 控制字符数组。
    0,          // 所属初始进程组。
    0,          // 初始停止标志。
    rs_write,       // 串口1 tty 写函数指针。
    {0x3f8, 0, 0, 0, ""},   /* rs 1 */// 串行终端1 读缓冲队列。
    {0x3f8, 0, 0, 0, ""},   // 串行终端1 写缓冲队列。
    {0, 0, 0, 0, ""}        // 串行终端1 辅助缓冲队列。
}, {
    {
        0,          /* no translation */// 输入模式标志。0，无须转换。
        0,          /* no translation */// 输出模式标志。0，无须转换。
        B2400 | CS8,    // 控制模式标志。波特率2400bps，8 位数据位。
        0,          // 本地模式标志0。
        0,          // 行规程0。
        INIT_C_CC
    },      // 控制字符数组。
    0,          // 所属初始进程组。
    0,          // 初始停止标志。
    rs_write,       // 串口2 tty 写函数指针。
    {0x2f8, 0, 0, 0, ""},   /* rs 2 */// 串行终端2 读缓冲队列。
    {0x2f8, 0, 0, 0, ""},   // 串行终端2 写缓冲队列。
    {0, 0, 0, 0, ""}    // 串行终端2 辅助缓冲队列。
}
};

```