#1.find_entry

```cpp
/*
 *  find_entry()
 *
 * 在指定的目录中寻找一个与名字匹配的目录项。返回一个含有找到目录项的高速
 * 缓冲区以及目录项本身(作为一个参数- res_dir)。并不读目录项的i 节点- 如
 * 果需要的话需自己操作。
 *
 * '..'目录项，操作期间也会对几种特殊情况分别处理- 比如横越一个伪根目录以
 * 及安装点。
 */
//// 查找指定目录和文件名的目录项。
// 参数：dir - 指定目录i 节点的指针；name - 文件名；namelen - 文件名长度；
// 返回：高速缓冲区指针；res_dir - 返回的目录项结构指针；

find_entry
// 计算本目录中目录项项数entries。置空返回目录项结构指针。
--entries = (*dir)->i_size / (sizeof (struct dir_entry));
/* 检查目录项'..'，因为可能需要对其特别处理 */
--if (namelen==2 && get_fs_byte(name)=='.' && get_fs_byte(name+1)=='.') {
/* 伪根中的'..'如同一个假'.'(只需改变名字长度) */
// 如果当前进程的根节点指针即是指定的目录，则将文件名修改为'.'，
        if ((*dir) == current->root)
            namelen=1;
// 否则如果该目录的i 节点号等于ROOT_INO(1)的话，说明是文件系统根节点。则取文件系统的超级块。
        else if ((*dir)->i_num == ROOT_INO) {
/* 在一个安装点上的'..'将导致目录交换到安装到文件系统的目录i 节点。
   注意！由于设置了mounted 标志，因而我们能够取出该新目录 */
            sb=get_super((*dir)->i_dev);
// 如果被安装到的i 节点存在，则先释放原i 节点，然后对被安装到的i 节点进行处理。
// 让*dir 指向该被安装到的i 节点；该i 节点的引用数加1。
            if (sb->s_imount) {
                iput(*dir);
                (*dir)=sb->s_imount;
                (*dir)->i_count++;
            }
        }
--}
```